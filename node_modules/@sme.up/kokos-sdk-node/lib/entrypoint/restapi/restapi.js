import express from "express";
import bodyParser from "body-parser";
import { plainToInstance } from "class-transformer";
import { validate } from "class-validator";
import { ValidationException } from "../../types/exceptions/validation.js";
import { ExecuteFunPayload, } from "../../types/general.js";
import { serviceCaller } from "../../caller/serviceCaller.js";
import { fileURLToPath } from "url";
import { dirname, normalize } from "path";
import stream from "stream";
import { ApiVersion, SMEUP_MESSAGE_GRAVITY, SMEUP_MESSAGE_MODE, } from "../../types/data-structures/smeupDataStructure.js";
import { init } from "../../configuration/configuration.js";
import { Format, LOGGER, Level, configureLogger } from "../../logger/logger.js";
// constant
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
export function startServer(microExecutorId) {
    startServerWithCustomConfig(microExecutorId, {
        server: {
            port: 8011,
        },
        logger: {
            format: Format.TXT,
            level: Level.DEBUG,
        },
    });
}
export function startServerWithCustomConfig(microExecutorId, defaultConfigurationClass, callback) {
    // load config
    const configuration = init(microExecutorId, defaultConfigurationClass);
    if (callback) {
        // call callback
        callback(configuration);
    }
    configureLogger(configuration.logger?.level, configuration.logger?.format);
    // create server
    const app = express();
    // body parse middleware
    app.use(bodyParser.json());
    // swagger
    const swaggerPath = normalize(`${__dirname}/../../../swagger`);
    app.use("/swagger", express.static(swaggerPath));
    // docs
    const docsPath = normalize(`${__dirname}/../../../docs`);
    app.use("/docs", express.static(docsPath));
    /**
     * REST API Entrypoint
     */
    /**
     * EXECUTION API
     */
    /**
     * /executeFun API
     */
    app.use("/api/:version/executeFun", validationMiddleware(ExecuteFunPayload), (req, res, next) => {
        // get version
        const version = req.params.version == "v2" ? ApiVersion.V2 : ApiVersion.V1;
        // get body
        const { fun, context } = req.body;
        // set status
        res.status(200);
        res.setHeader("Content-Type", "application/json");
        // create stream
        const out = new stream.Writable({
            write(chunk, encoding, callback) {
                res.write(chunk, encoding);
                callback();
            },
        });
        // call service caller
        serviceCaller(fun, context, out, version)
            .then(() => {
            res.end();
        })
            .catch((err) => {
            next(err);
        });
    });
    /**
     * MONITORING API
     */
    /**
     * /livez API
     */
    app.use("/api/v1/livez", async (req, res) => {
        res.status(200).send({
            status: "ok",
        });
    });
    /**
     * /readyz API
     */
    app.use("/api/v1/readyz", async (req, res) => {
        res.status(200).send({
            status: "ok",
        });
    });
    // error middleware
    app.use(errorMiddleware);
    // start server
    const PORT = configuration.server.port || 3000;
    app.listen(PORT, () => {
        LOGGER.info(`App listening on the port ${PORT}`);
    });
    /**
     * MIDDLEWARES
     */
    /**
     * Validation Middleware
     * Validate request body
     * @param type
     * @param skipMissingProperties
     * @returns
     */
    function validationMiddleware(type) {
        return (req, res, next) => {
            validate(plainToInstance(type, req.body)).then((errors) => {
                if (errors.length > 0) {
                    const message = errors
                        .map((error) => error.constraints && Object.values(error.constraints))
                        .join(", ");
                    next(new ValidationException(message));
                }
                else {
                    next();
                }
            });
        };
    }
    /**
     * Error Middleware
     * Handle all application error
     * @param error
     * @param request
     * @param response
     */
    function errorMiddleware(error, _request, response, _next) {
        const status = error.status || 500;
        const message = error.message || "Something went wrong";
        LOGGER.error(error);
        response.status(status).json({
            messages: [
                {
                    gravity: SMEUP_MESSAGE_GRAVITY.ERROR,
                    message: message,
                    mode: SMEUP_MESSAGE_MODE.PN,
                },
            ],
        });
    }
}
//# sourceMappingURL=restapi.js.map