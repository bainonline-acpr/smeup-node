import { ApiVersion, SmeupDataStructureType, getSmeupDataStructureType, } from "../types/data-structures/smeupDataStructure.js";
import { dataColumnToSmeupColumn, dataNodeToSmeupTreeNode, dataRowToSmeupRow, } from "./smeupDataStructureUtils.js";
var DATA_TYPE;
(function (DATA_TYPE) {
    DATA_TYPE["COLUMN"] = "COLUMN";
    DATA_TYPE["ROW"] = "ROW";
    DATA_TYPE["NODE"] = "NODE";
    DATA_TYPE["RAW_DATA"] = "RAW_DATA";
    DATA_TYPE["RAW_DATA_CONTENT"] = "RAW_DATA_CONTENT";
})(DATA_TYPE || (DATA_TYPE = {}));
export class SmeupDataStructureWriter {
    out;
    version;
    initalTimestamp;
    messages = [];
    dataColumns = [];
    firstElement = true;
    lastElementWritten;
    isInitializationWritten = false;
    isFinalizationWritten = false;
    isColumnWritten = false;
    isRowWritten = false;
    isNodeWritten = false;
    constructor(out, version) {
        this.initalTimestamp = new Date();
        this.out = out;
        this.version = version ? version : ApiVersion.V1;
    }
    writeDataStructureInitialization(fun) {
        if (!this.isInitializationWritten) {
            this.initalTimestamp = new Date();
            const type = getSmeupDataStructureType(fun, this.version);
            this.out.write(utf8Encode("{"));
            this.out.write(utf8Encode(`"type": "${type}"`));
            this.isInitializationWritten = true;
        }
    }
    writeDataStructureFinalization(fun) {
        if (!this.isFinalizationWritten) {
            const type = getSmeupDataStructureType(fun, this.version);
            switch (type) {
                case SmeupDataStructureType.SmeupTree:
                case SmeupDataStructureType.SmeupDataTree:
                    if (this.lastElementWritten != null) {
                        // close rows, columns or messages
                        this.out.write(utf8Encode("]"));
                    }
                    if (!this.isNodeWritten) {
                        this.out.write(utf8Encode(`,"children":[]`));
                    }
                    break;
                case SmeupDataStructureType.SmeupTable:
                case SmeupDataStructureType.SmeupDataTable:
                    // close rows or messages
                    if (this.lastElementWritten != null) {
                        // close rows, columns
                        this.out.write(utf8Encode("]"));
                    }
                    if (!this.isColumnWritten) {
                        this.out.write(utf8Encode(`,"columns":[]`));
                    }
                    if (!this.isRowWritten) {
                        this.out.write(utf8Encode(`,"rows":[]`));
                    }
                    break;
            }
            // messages
            this.out.write(utf8Encode(`,"messages":${JSON.stringify(this.messages)}`));
            // debug info
            const finalTimestamp = new Date();
            const debugInfo = {
                initialTimestamp: this.initalTimestamp.toISOString(),
                finalTimestamp: finalTimestamp.toISOString(),
                executionTime_ms: finalTimestamp.getTime() - this.initalTimestamp.getTime(),
            };
            this.out.write(utf8Encode(`,"debugInfo":${JSON.stringify(debugInfo)}`));
            this.out.write(utf8Encode("}"));
            this.out.end();
            this.isFinalizationWritten = true;
        }
    }
    /**
     * Write a SmeupDataNode instance to stream
     * @param node
     */
    writeDataNode(node) {
        if (this.lastElementWritten != null) {
            if (this.lastElementWritten != DATA_TYPE.NODE) {
                // close columns/messages/actions... array
                this.out.write(utf8Encode("]"));
                // children init
                this.out.write(utf8Encode(`,"children": [`));
                this.firstElement = true;
            }
        }
        else {
            // children init
            this.out.write(utf8Encode(`,"children": [`));
            this.firstElement = true;
        }
        // handle comma
        if (!this.firstElement) {
            this.out.write(utf8Encode(","));
        }
        if (this.version == ApiVersion.V1) {
            // write legacy tree node
            this.out.write(utf8Encode(JSON.stringify(dataNodeToSmeupTreeNode(node, this.dataColumns))));
        }
        else {
            // write data node
            this.out.write(utf8Encode(JSON.stringify(node)));
        }
        this.firstElement = false;
        this.lastElementWritten = DATA_TYPE.NODE;
        this.isNodeWritten = true;
    }
    /**
     * Write SmeupDataColumns
     * @param columns
     */
    writeDataColumns(columns) {
        columns.forEach((col) => {
            this.writeDataColumn(col);
        });
    }
    /**
     * Write a SmeupDataColumn
     * @param col
     */
    writeDataColumn(col) {
        if (this.lastElementWritten == null) {
            // column init
            this.out.write(utf8Encode(',"columns": ['));
            this.firstElement = true;
        }
        // handle comma
        if (!this.firstElement) {
            this.out.write(utf8Encode(","));
        }
        if (this.version == ApiVersion.V1) {
            this.out.write(utf8Encode(JSON.stringify(dataColumnToSmeupColumn(col))));
        }
        else {
            this.out.write(utf8Encode(JSON.stringify(col)));
        }
        this.firstElement = false;
        this.lastElementWritten = DATA_TYPE.COLUMN;
        this.isColumnWritten = true;
        // add to arraylist
        this.dataColumns.push(col);
    }
    writeDataRow(row) {
        if (this.lastElementWritten != null) {
            if (this.lastElementWritten != DATA_TYPE.ROW) {
                // close columns/messages/actions... array
                this.out.write(utf8Encode("]"));
                // rows init
                this.out.write(utf8Encode(`,"rows": [`));
                this.firstElement = true;
            }
        }
        else {
            // rows init
            this.out.write(utf8Encode(`,"rows": [`));
            this.firstElement = true;
        }
        // handle comma
        if (!this.firstElement) {
            this.out.write(utf8Encode(","));
        }
        if (this.version == ApiVersion.V1) {
            // write legacy row
            this.out.write(utf8Encode(JSON.stringify(dataRowToSmeupRow(row, this.dataColumns))));
        }
        else {
            // write row
            this.out.write(utf8Encode(JSON.stringify(row)));
        }
        this.firstElement = false;
        this.lastElementWritten = DATA_TYPE.ROW;
        this.isRowWritten = true;
    }
    writeMessage(message) {
        this.messages.push(message);
    }
    writeRawDataContent(content) {
        const data = `,"data": ` +
            JSON.stringify(`<?xml version=\"1.0\" encoding=\"UTF-8\"?><Base><Contenuto><![CDATA[${content}]]></Contenuto></Base>`);
        this.out.write(utf8Encode(data));
        this.lastElementWritten = DATA_TYPE.RAW_DATA_CONTENT;
    }
}
function utf8Encode(s) {
    return Buffer.from(s, "utf-8");
}
//# sourceMappingURL=smeupDataStructureWriter.js.map