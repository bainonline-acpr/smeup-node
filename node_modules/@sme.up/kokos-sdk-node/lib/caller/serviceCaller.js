import path from "path";
import url from "url";
import os from "os";
import { getProjectRoot } from "../utils/path.js";
import { SmeupDataStructureWriter } from "../utils/smeupDataStructureWriter.js";
import { ApiVersion, SMEUP_MESSAGE_GRAVITY, SMEUP_MESSAGE_MODE, } from "../types/data-structures/smeupDataStructure.js";
import { LOGGER, clearLoggerContext, createLoggerContext, } from "../logger/logger.js";
import { funToString } from "../utils/fun.js";
import { dispatch } from "./microExecutorServiceCaller.js";
import { globalConfiguration } from "../configuration/configuration.js";
/**
 * PROJECT FILE SYSTEM
 *
 * implementation project
 *   node_modules
 *     @sme.up
 *       kokos-template-node
 *         lib
 *           caller
 *             serviceCaller.js
 *
 *   src
 *     services
 *       [SOURCES_SERVICES (.ts)]
 *
 *   dist
 *     services
 *       [COMPILED_SERVICES (.js)]
 */
/**
 * Service Caller
 * Thows ExecutionException if
 * - service not found
 * - method not found
 * @param fun
 * @param context
 * @returns
 * @throws ExecutionException
 */
export async function serviceCaller(fun, context, out, version = ApiVersion.V1) {
    // setup logger context
    const loggerContext = {
        fun: funToString(fun),
        sessionId: context?.user?.sessionId ? context.user.sessionId : "",
        user: context?.user?.username ? context.user.username : "",
        environment: context?.user?.environment ? context.user.environment : "",
    };
    createLoggerContext(loggerContext);
    LOGGER.info(`Execute FUN ${loggerContext.fun}`);
    // check alias
    if (context?.env?.registry?.aliases?.[fun.service]) {
        fun.service = context.env.registry.aliases[fun.service];
    }
    // check service handler
    const handler = context?.env?.registry?.services?.[fun.service];
    if (handler && handler !== globalConfiguration.microExecutorId) {
        // dispatch to external service
        await dispatch(handler, fun, context, out, version);
    }
    else {
        // handle internally
        // get service path
        let servicePath = "";
        if (!process.env.NODE_ENV || process.env.NODE_ENV == "production") {
            servicePath = path.join(getProjectRoot(), "lib", "services", `${fun.service}.js`);
        }
        else if (process.env.NODE_ENV === "development" ||
            process.env.NODE_ENV === "test") {
            servicePath = path.join(getProjectRoot(), "src", "services", fun.service);
        }
        if (os.platform() === "win32") {
            servicePath = url.pathToFileURL(servicePath).toString();
        }
        // load service module
        let serviceModule;
        const writer = new SmeupDataStructureWriter(out, version);
        writer.writeDataStructureInitialization(fun);
        try {
            // import service by its name as es module
            serviceModule = await import(servicePath);
            // check method
            if (serviceModule.default.methods[fun.function]) {
                // call method
                try {
                    await serviceModule.default.methods[fun.function](fun, context, writer);
                }
                catch (error) {
                    LOGGER.error(error);
                    writer.writeMessage({
                        gravity: SMEUP_MESSAGE_GRAVITY.ERROR,
                        mode: SMEUP_MESSAGE_MODE.PN,
                        message: error.message,
                    });
                }
            }
            else {
                writer.writeMessage({
                    gravity: SMEUP_MESSAGE_GRAVITY.ERROR,
                    mode: SMEUP_MESSAGE_MODE.PN,
                    message: `Method "${fun.function ? fun.function : ""}" not found for service "${fun.service}"`,
                });
            }
        }
        catch (error) {
            LOGGER.error(error);
            writer.writeMessage({
                gravity: SMEUP_MESSAGE_GRAVITY.ERROR,
                mode: SMEUP_MESSAGE_MODE.PN,
                message: `Service "${fun.service}" not found: ${error.message}`,
            });
        }
        writer.writeDataStructureFinalization(fun);
    }
    clearLoggerContext();
}
//# sourceMappingURL=serviceCaller.js.map