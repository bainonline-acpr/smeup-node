import { ApiVersion, SMEUP_MESSAGE_GRAVITY, } from "../types/data-structures/smeupDataStructure.js";
import axios from "axios";
import { funToString } from "../utils/fun.js";
const EXECUTE_FUN_V1 = "/api/v1/executeFun";
const EXECUTE_FUN_V2 = "/api/v2/executeFun";
/**
 * Determines the API path based on the provided version.
 * @param version The API version, either "V1" or "V2".
 * @returns The API path.
 */
const getPath = (version) => {
    return version === ApiVersion.V1 ? EXECUTE_FUN_V1 : EXECUTE_FUN_V2;
};
/**
 * Dispatches the execution of a function to the micro-executor service.
 * @param handler The handler name.
 * @param fun The Fun object.
 * @param context The ExecutionContext object.
 * @param out The OutputStream object.
 * @throws Exception
 */
export async function dispatch(handler, fun, context, out, version = ApiVersion.V1) {
    const handlerUrl = context?.env?.registry?.handlers?.[handler];
    if (handlerUrl) {
        const url = handlerUrl + getPath(version);
        const dto = {
            fun: fun,
            context: context,
        };
        const response = await axios.post(url, dto, {
            headers: { "Content-Type": "application/json" },
        });
        const code = response.status;
        if (code < 200 || code > 300) {
            throw new Error(`HTTP request to '${url}' failed. Response code: ${code}. Response: ${response.data}`);
        }
        // handle applicative errors
        if (response.data.messages?.length > 0) {
            for (const message of response.data.messages) {
                if (message.gravity === SMEUP_MESSAGE_GRAVITY.ERROR) {
                    throw new Error(`Error calling FUN ${funToString(fun)}: ${message.message}`);
                }
            }
        }
        out.write(Buffer.from(JSON.stringify(response.data), "utf8"));
    }
    else {
        throw new Error(`Handler ${handler} not defined`);
    }
}
//# sourceMappingURL=microExecutorServiceCaller.js.map